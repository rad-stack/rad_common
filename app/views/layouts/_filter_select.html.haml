- filter_class = search.default_value?(filter.searchable_name) ? '' : 'filter-active'
- input_html = filter.search_scope_params
-# - if filter.is_a?(RadCommon::ArrayFilter)
-#   = render 'layouts/match_type_dropdown', search: search, filter: filter, f: f

.row.align-items-center{ data: { controller: 'search-match-type-filter' } }
  - if filter.is_a?(RadCommon::ArrayFilter)
    - match_type_value = search.search_params[filter.match_type_param] || filter.default_match_type
    .col
      = f.label filter.array_input, filter.input_label, required: false
    .col-auto
      .dropdown{ data: { testid: "#{filter.match_type_param}_match_dropdown" } }
        = f.hidden_field filter.match_type_param, value: match_type_value, data: { search_match_type_filter_target: 'input' }
        %span.dropdown-toggle{ type: 'button', data: { toggle: 'dropdown' } }
          %i.fa.fa-filter
        %ul.dropdown-menu.dropdown-menu-right{ data: { search_match_type_filter_target: 'menu' } }
          - filter.match_types.each do |type|
            %li
              - data = { action: 'click->search-match-type-filter#select', match_type: type, match_type_label: type.titleize }
              %a.dropdown-item{ href: '#', data: data }
                .d-flex.align-items-center.justify-content-between
                  = type.titleize
                  %i.fa.fa-check.text-muted.px-2{ class: (type == match_type_value ? '' : 'd-none') }
        %span.text-muted.ml-2{ data: { search_match_type_filter_target: 'label' } }
          = match_type_value.titleize
  - else
    .col
      = f.label filter.input_label, required: false
  - if filter.allow_not
    .col-auto
      = f.input "#{filter.searchable_name}_not",
                as: :boolean,
                label: 'Exclude',
                input_html: { checked: filter.not_value?(params[:search]) },
                wrapper_html: { class: 'text-right mb-0' },
                tooltip: "Exclude results that match selected #{filter.input_label}"
= f.input filter.searchable_name,
          collection: filter.input_options_with_current_selection(search),
          label: false,
          selected: filter.selected_value(search),
          include_blank: filter.include_blank ? filter.blank_value_label : false,
          as: filter.input_type,
          group_method: :last,
          required: false,
          wrapper_html: { class: filter_class },
          input_html: { multiple: filter.multiple, 'data-placeholder': filter.blank_value_label }.merge(input_html)
